//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by TestShell Driver Builder Version 8.2.0.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#define TRACE
using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Diagnostics;
using System.Security.Permissions;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Proxies;
using System.Collections.Generic;
using System.ComponentModel;
using Microsoft.Win32;
using QualiSystems.Libraries;
using QualiSystems.Driver;

[assembly: AssemblyVersion("1.0.1808.30995")]
[assembly: AssemblyFileVersion("1.0.1808.30995")]
[assembly: AssemblyTitle("A CloudShell Automation API wrapper for the ixNetwork Controller Shell to be used within TestShell")]
[assembly: AssemblyProduct("[<AssemblyName>] 8.2.0")]
[assembly: Library(typeof(IXN), "", IsolationLevel.PerLibrary)]




namespace QualiSystems.Driver
{
	[Description("A CloudShell Automation API wrapper for the ixNetwork Controller Shell to be used within TestShell")]
    public class IXN : ICancelable, IDisposable
    {
        private static readonly Assembly DriverRuntimeAssembly;
        private static readonly string DriverRuntimeTypeName;
        private static readonly string DriverCodeBase;
		private Guid m_DriverIdentifier;
        
		private IFunctionInterpreter m_Load_ConfigurationFunctionInterpreter = null;
		private object m_Load_ConfigurationFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Send_ARPFunctionInterpreter = null;
		private object m_Send_ARPFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Start_ProtocolsFunctionInterpreter = null;
		private object m_Start_ProtocolsFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Get_StatisticsFunctionInterpreter = null;
		private object m_Get_StatisticsFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Start_TrafficFunctionInterpreter = null;
		private object m_Start_TrafficFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Stop_TrafficFunctionInterpreter = null;
		private object m_Stop_TrafficFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_killFunctionInterpreter = null;
		private object m_killFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_setFunctionInterpreter = null;
		private object m_setFunctionInterpreterLock = new object();

		
		static IXN()
		{
			DriverCodeBase = Assembly.GetExecutingAssembly().CodeBase;
			TestShellRuntimeLocator runtimeLocator = new TestShellRuntimeLocator("8.2.0");
            DriverRuntimeAssembly = runtimeLocator.RuntimeAssembly;
            DriverRuntimeTypeName = runtimeLocator.RuntimeTypeName;
		}
		
		private void __Shutdown() 
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			runtimeType.GetMethod("Shutdown").Invoke(null, BindingFlags.Public | BindingFlags.Static, null, new object[0], null);
		}

        public IXN()
        {
			m_DriverIdentifier = Guid.NewGuid();

			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			bool IsSupportedVersion = (bool)runtimeType.GetMethod("IsSupportedRuntimeVersion").Invoke(null, new object[]{"8.2.0"});
			if (!IsSupportedVersion)
				throw TestShellRuntimeLocator.NoMatchingRuntimeException("8.2.0");

			runtimeType.GetMethod("InitializeRuntime").Invoke(null, new object[]{Assembly.GetExecutingAssembly().CodeBase, "IXN", m_DriverIdentifier.ToString()});
                      
			m_Load_ConfigurationFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Config\\Load Configuration.tsdrv");
			m_Send_ARPFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Protocols\\Send ARP.tsdrv");
			m_Start_ProtocolsFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Protocols\\Start Protocols.tsdrv");
			m_Get_StatisticsFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Statistics\\Get Statistics.tsdrv");
			m_Start_TrafficFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Traffic\\Start Traffic.tsdrv");
			m_Stop_TrafficFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Traffic\\Stop Traffic.tsdrv");
			m_killFunctionInterpreter = CreateFunctionInterpreter("IXN\\Session\\kill.tsdrv");
			m_setFunctionInterpreter = CreateFunctionInterpreter("IXN\\Session\\set.tsdrv");

        }
        

        
		[Hidden]
		public CancellationContext CreateCancellationContext()
		{
			return new CancellationContext();
		}

		[Hidden]
		public bool Cancel(CancellationContext cancellationContext)
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			return (bool)runtimeType.GetMethod("Cancel").Invoke(null, new object[]{cancellationContext.CallId});
		}

		[Hidden]
		public void Dispose()
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			runtimeType.GetMethod("DisposeDriverInstance").Invoke(null, new object[]{m_DriverIdentifier.ToString()});
		}

        private IFunctionInterpreter CreateFunctionInterpreter(string functionVirtualPath)
        {
            return new DucktypingProxy<IFunctionInterpreter>(DriverRuntimeAssembly.CreateInstance(
                    DriverRuntimeTypeName, false, BindingFlags.Default, null, new object[] { m_DriverIdentifier.ToString(), functionVirtualPath }, null, null)).TransparentProxy;
        }

		[Description("Reserve ports and load configuration")]
		[Alias("Load Configuration")]
		[Folder("ixNetwork\\Config")]
		[Cancelable]
		public void @Load_Configuration([Alias("Breaking Point config file")][Mandatory]  string @Breaking_Point_config_file, [Alias("ExecuteCommand_output")] out string @ExecuteCommand_output)
		{
			lock(m_Load_ConfigurationFunctionInterpreterLock)
			{
				if(m_Load_ConfigurationFunctionInterpreter == null)
					m_Load_ConfigurationFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Config\\Load Configuration.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["ConfigFile"] = @Breaking_Point_config_file;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["ExecuteCommand.output"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_Load_ConfigurationFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@ExecuteCommand_output =  (string)outputNamesValues["ExecuteCommand.output"];
		}

		[Alias("Send ARP")]
		[Folder("ixNetwork\\Protocols")]
		[Cancelable]
		public void @Send_ARP([Alias("CommandOutput")] out string @CommandOutput)
		{
			lock(m_Send_ARPFunctionInterpreterLock)
			{
				if(m_Send_ARPFunctionInterpreter == null)
					m_Send_ARPFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Protocols\\Send ARP.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["genericNoInputCmd1.CommandOutput"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_Send_ARPFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@CommandOutput =  (string)outputNamesValues["genericNoInputCmd1.CommandOutput"];
		}

		[Alias("Start Protocols")]
		[Folder("ixNetwork\\Protocols")]
		[Cancelable]
		public void @Start_Protocols([Alias("CommandOutput")] out string @CommandOutput)
		{
			lock(m_Start_ProtocolsFunctionInterpreterLock)
			{
				if(m_Start_ProtocolsFunctionInterpreter == null)
					m_Start_ProtocolsFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Protocols\\Start Protocols.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["genericNoInputCmd1.CommandOutput"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_Start_ProtocolsFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@CommandOutput =  (string)outputNamesValues["genericNoInputCmd1.CommandOutput"];
		}

		[Description("Get real time statistics")]
		[Alias("Get Statistics")]
		[Folder("ixNetwork\\Statistics")]
		[Cancelable]
		public void @Get_Statistics([Alias("View Name")][ParameterDefaultValue("summary")]  string @View_Name, [Alias("Output Type")][ParameterDefaultValue("csv")]  OutputType @Output_Type, [Alias("CommandOutput")] out string @CommandOutput)
		{
			lock(m_Get_StatisticsFunctionInterpreterLock)
			{
				if(m_Get_StatisticsFunctionInterpreter == null)
					m_Get_StatisticsFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Statistics\\Get Statistics.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["ViewName"] = @View_Name;
			inputNamesValues["OutputType"] = @Output_Type;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["ExecuteCommand.output"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_Get_StatisticsFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@CommandOutput =  (string)outputNamesValues["ExecuteCommand.output"];
		}

		[Description("Start test for current configuration")]
		[Alias("Start Traffic")]
		[Folder("ixNetwork\\Traffic")]
		[Cancelable]
		public void @Start_Traffic([Alias("Block")][ParameterDefaultValue("False")]  Bool @Block, [Alias("ExecuteCommand_output")] out string @ExecuteCommand_output)
		{
			lock(m_Start_TrafficFunctionInterpreterLock)
			{
				if(m_Start_TrafficFunctionInterpreter == null)
					m_Start_TrafficFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Traffic\\Start Traffic.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["Block"] = @Block;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["ExecuteCommand.output"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_Start_TrafficFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@ExecuteCommand_output =  (string)outputNamesValues["ExecuteCommand.output"];
		}

		[Description("Stop running test")]
		[Alias("Stop Traffic")]
		[Folder("ixNetwork\\Traffic")]
		[Cancelable]
		public void @Stop_Traffic()
		{
			lock(m_Stop_TrafficFunctionInterpreterLock)
			{
				if(m_Stop_TrafficFunctionInterpreter == null)
					m_Stop_TrafficFunctionInterpreter = CreateFunctionInterpreter("IXN\\ixNetwork\\Traffic\\Stop Traffic.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Stop_TrafficFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Session")]
		[EndSession,Hidden]
		[Cancelable]
		public void @kill()
		{
			lock(m_killFunctionInterpreterLock)
			{
				if(m_killFunctionInterpreter == null)
					m_killFunctionInterpreter = CreateFunctionInterpreter("IXN\\Session\\kill.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_killFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Session")]
		[StartSession,Hidden]
		[Cancelable]
		public void @set([Alias("CloudShell Server")]  string @server, [Alias("Sandbox ID")]  string @sandboxID, [Alias("Username")]  string @APIUsername, [Alias("Password")]  string @APIPassword, [Alias("Domain")]  string @APIDomain1)
		{
			lock(m_setFunctionInterpreterLock)
			{
				if(m_setFunctionInterpreter == null)
					m_setFunctionInterpreter = CreateFunctionInterpreter("IXN\\Session\\set.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["server"] = @server;
			inputNamesValues["sandboxID"] = @sandboxID;
			inputNamesValues["APIUsername"] = @APIUsername;
			inputNamesValues["APIPassword"] = @APIPassword;
			inputNamesValues["APIDomain"] = @APIDomain1;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_setFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}


   
        #region DucktypingProxy
        
		[DebuggerStepThrough]
		internal class DucktypingProxy<TTarget> : RealProxy where TTarget : class
		{
			private object m_Target;

			public DucktypingProxy(object target) : base(typeof(TTarget))
			{
				m_Target = target;
			}

			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
			public override IMessage Invoke(IMessage msg)
			{
				IMethodCallMessage methodMessage = new MethodCallMessageWrapper((IMethodCallMessage)msg);
				MethodBase method = methodMessage.MethodBase;
				object returnValue = null;
				ReturnMessage returnMessage = null;

				try
				{
					MethodBase targetMethod = GetTargetMethodFromInterfaceMethod(method);
					if (targetMethod == null)
						throw new NotImplementedException(string.Format("Method {0} was not implemented by the target", method.Name));
					returnValue = targetMethod.Invoke(m_Target, methodMessage.Args);
					returnMessage = new ReturnMessage(returnValue, methodMessage.Args, methodMessage.ArgCount, methodMessage.LogicalCallContext, methodMessage);
				}
				catch (Exception ex)
				{
					if ((ex is RemotingException || ex is TargetInvocationException)
						&& ex.InnerException != null)
						ex = ex.InnerException;

					returnMessage = new ReturnMessage(ex, methodMessage);
				}

				return returnMessage;
			}

			private MethodBase GetTargetMethodFromInterfaceMethod(MethodBase interfaceMethod)
			{
				ParameterInfo[] interfaceMethodParameters = interfaceMethod.GetParameters();
				Type[] parameterTypes = new Type[interfaceMethodParameters.Length];
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					parameterTypes[i] = interfaceMethodParameters[i].ParameterType;
				}

				MethodInfo targetMethod;
				if (interfaceMethod.IsGenericMethod)
					targetMethod = m_Target.GetType().GetMethod(interfaceMethod.Name, parameterTypes).MakeGenericMethod(interfaceMethod.GetGenericArguments());
				else
					targetMethod = m_Target.GetType().GetMethod(interfaceMethod.Name, parameterTypes);

				return targetMethod;
			}

			public TTarget TransparentProxy
			{
				get
				{
					return base.GetTransparentProxy() as TTarget;
				}
			}
		}
		
		#endregion DucktypingProxy
		
		#region TestShellRuntimeLocator

        internal class TestShellRuntimeLocator
        {
            private const string RuntimeRepositoryPath = @"Software\QualiSystems\TestShellRuntime";

            public Assembly RuntimeAssembly { get; private set; }
            public string RuntimeTypeName { get; private set; }

            public TestShellRuntimeLocator(string targetRuntimeVersion)
            {
				Trace.WriteLine("Quali Runtime: Target runtime version is " +targetRuntimeVersion+ ", searching for matching installed versions...");
                var runtimeInfos = ReadInstalledTestShellRuntimeInfos(targetRuntimeVersion);
                TestShellRuntimeInfo selectedRuntimeInfo = SelectRuntimeVersionInfo(runtimeInfos, targetRuntimeVersion);
                RuntimeTypeName = selectedRuntimeInfo.RuntimeTypeName;
                string runtimeAssemblyPath = Path.Combine(selectedRuntimeInfo.Path, selectedRuntimeInfo.RuntimeAssemblyName);
                if (!System.IO.File.Exists(runtimeAssemblyPath))
                    throw RuntimeAssemblyNotFound(runtimeAssemblyPath);
                Trace.WriteLine("Quali Runtime: Loading runtime version " +selectedRuntimeInfo.Version+ " from " + runtimeAssemblyPath);
                RuntimeAssembly = Assembly.LoadFrom(runtimeAssemblyPath);
            }

            private static TestShellRuntimeInfo SelectRuntimeVersionInfo(IEnumerable<TestShellRuntimeInfo> runtimeInfos, string targetRuntimeVersion)
            {
                TestShellRuntimeInfo runtimeInfo = GetCurrentlyLoadedRuntimeInfo(runtimeInfos);
                if (runtimeInfo != null)
                {
                    if(!IsGreaterOrEqualVersion(runtimeInfo.Version, targetRuntimeVersion))
                        throw IncompatibleRuntimeLoaded(targetRuntimeVersion, runtimeInfo.Version);
                }
                else
                {
					var matchingRuntimeInfos = GetMatchingRuntimeInfos(runtimeInfos, targetRuntimeVersion);
					if (!matchingRuntimeInfos.Any())
						throw NoMatchingRuntimeException(targetRuntimeVersion);

					var licensedRuntimeInfos = GetLicensedRuntimeInfos(matchingRuntimeInfos);
					if (!licensedRuntimeInfos.Any())
						throw NoRuntimeLicenseException(targetRuntimeVersion);

                    runtimeInfo = GetBestMatchRuntimeInfo(licensedRuntimeInfos);
                }
                return runtimeInfo;
            }

			private static IEnumerable<TestShellRuntimeInfo> GetMatchingRuntimeInfos(IEnumerable<TestShellRuntimeInfo> runtimeInfos, string targetRuntimeVersion)
            {
				return runtimeInfos.
                    Where(r => IsGreaterOrEqualVersion(r.Version, targetRuntimeVersion)).	//only matching versions
					ToList();
			}
			
			private static IEnumerable<TestShellRuntimeInfo> GetLicensedRuntimeInfos(IEnumerable<TestShellRuntimeInfo> runtimeInfos)
			{
				return runtimeInfos.
					Where(IsLicenseValid).													//only licensed runtimes
					ToList();
			}

            private static TestShellRuntimeInfo GetBestMatchRuntimeInfo(IEnumerable<TestShellRuntimeInfo> runtimeInfos)
            {
                TestShellRuntimeInfo bestMatchRuntimeInfo = runtimeInfos.                    
                    OrderBy(r=>VersionStringToComparableNumber(r.Version)).FirstOrDefault();//best match
                return bestMatchRuntimeInfo;
            }

			private static bool IsLicenseValid(TestShellRuntimeInfo testShellRuntimeInfo)
			{
				string runtimeAssemblyPath = Path.Combine(testShellRuntimeInfo.Path, testShellRuntimeInfo.RuntimeAssemblyName);
				AppDomainSetup appDomainSetup = new AppDomainSetup();
				appDomainSetup.ApplicationBase = testShellRuntimeInfo.Path;
				AppDomain appDomain = AppDomain.CreateDomain("LicenseValidationDomain", AppDomain.CurrentDomain.Evidence, appDomainSetup);
				UnloadableLicenseValidator unloadableLicenseValidator = (UnloadableLicenseValidator)appDomain.CreateInstanceFromAndUnwrap(
                Assembly.GetExecutingAssembly().CodeBase, "QualiSystems.Driver.IXN+TestShellRuntimeLocator+UnloadableLicenseValidator");
				bool isRuntimeLicenseValid = unloadableLicenseValidator.IsLicenseValid(runtimeAssemblyPath, testShellRuntimeInfo.RuntimeLicenseValidatorTypeName);
				AppDomain.Unload(appDomain);
				Trace.WriteLine("Quali Runtime: Runtime at " +testShellRuntimeInfo.Path+ " is " + (isRuntimeLicenseValid ? "Licensed" : "Unlicenced"));
				return isRuntimeLicenseValid;
			}

            private static bool IsGreaterOrEqualVersion(string comparedVersion, string baseVersion)
            {
                int comparedVersionWeighted = VersionStringToComparableNumber(comparedVersion);
                int baseVersionWeighted = VersionStringToComparableNumber(baseVersion);
                return comparedVersionWeighted >= baseVersionWeighted;
            }

            private static int VersionStringToComparableNumber(string version)
            {
                string[] versionParts = version.Split('.');
                int major = int.Parse(versionParts[0]);
                int minor = int.Parse(versionParts[1]);
                return (major << 16) + minor;
            }

            private static TestShellRuntimeInfo GetCurrentlyLoadedRuntimeInfo(IEnumerable<TestShellRuntimeInfo> readTestShellRuntimeInfo)
            {
                TestShellRuntimeInfo matchingRuntime = null;
                foreach (var loadedAssembly in AppDomain.CurrentDomain.GetAssemblies())
                {
                    try
                    {
                        matchingRuntime = readTestShellRuntimeInfo.FirstOrDefault(r => string.Equals(loadedAssembly.Location, Path.Combine(r.Path, r.RuntimeAssemblyName), StringComparison.InvariantCultureIgnoreCase));
                        if (matchingRuntime != null)
						{
							Trace.WriteLine("Quali Runtime: "+ string.Format("Runtime version {0} already loaded.", matchingRuntime.Version));
                            break;
						}
                    }
                    catch (NotSupportedException)
                    {}
                }
                return matchingRuntime;
            }

            private static IEnumerable<TestShellRuntimeInfo> ReadInstalledTestShellRuntimeInfos(string targetRuntimeVersion)
            {
                RegistryKey testShellRuntimeRepositoryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(RuntimeRepositoryPath);
                if (testShellRuntimeRepositoryKey == null || testShellRuntimeRepositoryKey.SubKeyCount == 0)
                    throw NoMatchingRuntimeException(targetRuntimeVersion);

                List<TestShellRuntimeInfo> testShellRuntimeInfos = new List<TestShellRuntimeInfo>();
                foreach (var subKeyName in testShellRuntimeRepositoryKey.GetSubKeyNames())
                {
                    var runtimeKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(Path.Combine(RuntimeRepositoryPath,subKeyName));
                    TestShellRuntimeInfo testShellRuntimeInfo = new TestShellRuntimeInfo();
                    testShellRuntimeInfo.Path = (string) runtimeKey.GetValue("Path");
                    testShellRuntimeInfo.Version = (string)runtimeKey.GetValue("RuntimeVersion") ?? (string)runtimeKey.GetValue("Version");
                    testShellRuntimeInfo.RuntimeAssemblyName = (string)runtimeKey.GetValue("RuntimeAssembly");
                    testShellRuntimeInfo.RuntimeTypeName = (string)runtimeKey.GetValue("RuntimeType");
                    testShellRuntimeInfo.RuntimeLicenseValidatorTypeName = (string)runtimeKey.GetValue("RuntimeLicenseValidatorType");
                    testShellRuntimeInfos.Add(testShellRuntimeInfo);
                }
                return testShellRuntimeInfos;
            }

            private static Exception IncompatibleRuntimeLoaded(string targetRuntimeVersion, string loadedRuntimeVersion)
            {
                return new ApplicationException(string.Format("Quali runtime version {0} needed but version {1} already loaded.", targetRuntimeVersion, loadedRuntimeVersion));
            }

            private static Exception RuntimeAssemblyNotFound(string runtimeAssemblyPath)
            {
                return new ApplicationException("Runtime assembly "+runtimeAssemblyPath+" is missing.");
            }

			public static Exception NoMatchingRuntimeException(string targetRuntimeVersion)
			{
				return TestShellRuntimeException("Could not find a matching TestShell Runtime with version " + targetRuntimeVersion,
												 targetRuntimeVersion,
												 "MatchingRuntimeNotFound");
			}

			private static Exception NoRuntimeLicenseException(string targetRuntimeVersion)
			{
				return TestShellRuntimeException("Could not find a license for TestShell Runtime version " + targetRuntimeVersion,
												 targetRuntimeVersion,
												 "RuntimeLicenseNotFound");
			}

			private static Exception TestShellRuntimeException(string description, string targetRuntimeVersion, string reason)
			{
				KeyValuePair<string, string>[] parameters = new[]
				{
					new KeyValuePair<string, string>("Target Version", targetRuntimeVersion),
					new KeyValuePair<string, string>("Reason", reason)
				};
				return new ErrorException("Quali Runtime", description, string.Empty, parameters);
			}

            private class TestShellRuntimeInfo
            {
                public string Path { get; set; }
                public string Version { get; set; }
                public string RuntimeAssemblyName { get; set; }
                public string RuntimeTypeName { get; set; }
                public string RuntimeLicenseValidatorTypeName { get; set; }
            }

			internal class UnloadableLicenseValidator : MarshalByRefObject
			{
				public bool IsLicenseValid(string runtimeAssemblyPath, string runtimeLicenseValidatorTypeName)
				{
					Assembly runtimeAssembly = Assembly.LoadFrom(runtimeAssemblyPath);
					Type runtimeLicenseValidatorType = runtimeAssembly.GetType(runtimeLicenseValidatorTypeName);
					bool isRuntimeLicenseValid = (bool)runtimeLicenseValidatorType.GetMethod("IsRuntimeLicenseValid").Invoke(null, null);
					return isRuntimeLicenseValid;
				}
			}
        }

        #endregion TestShellRuntimeLocator

		interface IFunctionInterpreter
		{
			Dictionary<string, object> Run(Guid callId, Dictionary<string, object> inputNamesValues, Dictionary<string, Type> outputNamesTypes);
		}
    }

		public enum Bool
	{
		False=0,
		True=1
	}

	public enum ViewName
	{
		summary=0,
		iface=1,
		l4stats=2,
		sslstats=3,
		ipsecstats=4,
		l7stats=5,
		clientstats=6,
		attackstats=7
	}

	public enum OutputType
	{
		csv=0,
		json=1
	}


}